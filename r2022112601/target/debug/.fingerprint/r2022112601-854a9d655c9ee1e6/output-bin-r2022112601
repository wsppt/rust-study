{"message":"closure may outlive the current function, but it borrows `data`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n\nThis error may also be encountered while using `async` blocks:\n\n```compile_fail,E0373,edition2018\nuse std::future::Future;\n\nasync fn f() {\n    let v = vec![1, 2, 3i32];\n    spawn(async { //~ ERROR E0373\n        println!(\"{:?}\", v)\n    });\n}\n\nfn spawn<F: Future + Send + 'static>(future: F) {\n    unimplemented!()\n}\n```\n\nSimilarly to closures, `async` blocks are not executed immediately and may\ncapture closed-over data by reference. For more information, see\nhttps://rust-lang.github.io/async-book/03_async_await/01_chapter.html.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":153,"byte_end":157,"line_start":6,"line_end":6,"column_start":23,"column_end":27,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":23,"highlight_end":27}],"label":"`data` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":149,"byte_end":151,"line_start":6,"line_end":6,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":19,"highlight_end":21}],"label":"may outlive borrowed value `data`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":135,"byte_end":167,"line_start":6,"line_end":6,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `data` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":149,"byte_end":149,"line_start":6,"line_end":6,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"move ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `data`, which is owned by the current function\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:6:19\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 500; });\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`data` is borrowed here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `data`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:6:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 500; });\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `data` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    thread::spawn(\u001b[0m\u001b[0m\u001b[38;5;10mmove \u001b[0m\u001b[0m|| {data = 500; });\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"message":"cannot borrow `data` as mutable more than once at a time","code":{"code":"E0499","explanation":"A variable was borrowed as mutable more than once.\n\nErroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in Rust, you can either have many immutable references, or one\nmutable reference. For more details you may want to read the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n\nExample:\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":149,"byte_end":151,"line_start":6,"line_end":6,"column_start":19,"column_end":21,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":19,"highlight_end":21}],"label":"first mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":187,"byte_end":189,"line_start":7,"line_end":7,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":19,"highlight_end":21}],"label":"second mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":153,"byte_end":157,"line_start":6,"line_end":6,"column_start":23,"column_end":27,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":23,"highlight_end":27}],"label":"first borrow occurs due to use of `data` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":191,"byte_end":195,"line_start":7,"line_end":7,"column_start":23,"column_end":27,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":23,"highlight_end":27}],"label":"second borrow occurs due to use of `data` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":135,"byte_end":167,"line_start":6,"line_end":6,"column_start":5,"column_end":37,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":5,"highlight_end":37}],"label":"argument requires that `data` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0499]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `data` as mutable more than once at a time\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:19\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 500; });\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst borrow occurs due to use of `data` in closure\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst mutable borrow occurs here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `data` is borrowed for `'static`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 1000;});\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12msecond borrow occurs due to use of `data` in closure\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9msecond mutable borrow occurs here\u001b[0m\n\n"}
{"message":"closure may outlive the current function, but it borrows `data`, which is owned by the current function","code":{"code":"E0373","explanation":"A captured variable in a closure may not live long enough.\n\nErroneous code example:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure as shown in the previous code example.\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behavior is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n\nThis error may also be encountered while using `async` blocks:\n\n```compile_fail,E0373,edition2018\nuse std::future::Future;\n\nasync fn f() {\n    let v = vec![1, 2, 3i32];\n    spawn(async { //~ ERROR E0373\n        println!(\"{:?}\", v)\n    });\n}\n\nfn spawn<F: Future + Send + 'static>(future: F) {\n    unimplemented!()\n}\n```\n\nSimilarly to closures, `async` blocks are not executed immediately and may\ncapture closed-over data by reference. For more information, see\nhttps://rust-lang.github.io/async-book/03_async_await/01_chapter.html.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":191,"byte_end":195,"line_start":7,"line_end":7,"column_start":23,"column_end":27,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":23,"highlight_end":27}],"label":"`data` is borrowed here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":187,"byte_end":189,"line_start":7,"line_end":7,"column_start":19,"column_end":21,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":19,"highlight_end":21}],"label":"may outlive borrowed value `data`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function requires argument type to outlive `'static`","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":173,"byte_end":205,"line_start":7,"line_end":7,"column_start":5,"column_end":37,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":5,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"to force the closure to take ownership of `data` (and any other referenced variables), use the `move` keyword","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":187,"byte_end":187,"line_start":7,"line_end":7,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"    thread::spawn(|| {data = 1000;});","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"move ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0373]\u001b[0m\u001b[0m\u001b[1m: closure may outlive the current function, but it borrows `data`, which is owned by the current function\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:19\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 1000;});\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m`data` is borrowed here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmay outlive borrowed value `data`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: function requires argument type to outlive `'static`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 1000;});\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: to force the closure to take ownership of `data` (and any other referenced variables), use the `move` keyword\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    thread::spawn(\u001b[0m\u001b[0m\u001b[38;5;10mmove \u001b[0m\u001b[0m|| {data = 1000;});\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[38;5;10m++++\u001b[0m\n\n"}
{"message":"cannot borrow `data` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"A variable already borrowed as immutable was borrowed as mutable.\n\nErroneous code example:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let y = &a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let y = &a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on Rust's ownership system, take a look at the\n[References & Borrowing][references-and-borrowing] section of the Book.\n\n[references-and-borrowing]: https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":227,"byte_end":231,"line_start":9,"line_end":9,"column_start":20,"column_end":24,"is_primary":true,"text":[{"text":"    println!(\"{}\", data);","highlight_start":20,"highlight_end":24}],"label":"immutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/lijunzhang/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":4158,"byte_end":4191,"line_start":136,"line_end":136,"column_start":28,"column_end":61,"is_primary":false,"text":[{"text":"        $crate::io::_print($crate::format_args_nl!($($arg)*));","highlight_start":28,"highlight_end":61}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/main.rs","byte_start":212,"byte_end":232,"line_start":9,"line_end":9,"column_start":5,"column_end":25,"is_primary":false,"text":[{"text":"    println!(\"{}\", data);","highlight_start":5,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"println!","def_site_span":{"file_name":"/Users/lijunzhang/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/std/src/macros.rs","byte_start":4036,"byte_end":4056,"line_start":131,"line_end":131,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"macro_rules! println {","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::format_args_nl!","def_site_span":{"file_name":"/Users/lijunzhang/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/macros/mod.rs","byte_start":31203,"byte_end":31230,"line_start":907,"line_end":907,"column_start":5,"column_end":32,"is_primary":false,"text":[{"text":"    macro_rules! format_args_nl {","highlight_start":5,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/main.rs","byte_start":149,"byte_end":151,"line_start":6,"line_end":6,"column_start":19,"column_end":21,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":19,"highlight_end":21}],"label":"mutable borrow occurs here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":153,"byte_end":157,"line_start":6,"line_end":6,"column_start":23,"column_end":27,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":23,"highlight_end":27}],"label":"first borrow occurs due to use of `data` in closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":135,"byte_end":167,"line_start":6,"line_end":6,"column_start":5,"column_end":37,"is_primary":false,"text":[{"text":"    thread::spawn(|| {data = 500; });","highlight_start":5,"highlight_end":37}],"label":"argument requires that `data` is borrowed for `'static`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0502]\u001b[0m\u001b[0m\u001b[1m: cannot borrow `data` as immutable because it is also borrowed as mutable\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:9:20\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    thread::spawn(|| {data = 500; });\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--------------------------------\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mfirst borrow occurs due to use of `data` in closure\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmutable borrow occurs here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12margument requires that `data` is borrowed for `'static`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    println!(\"{}\", data);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mimmutable borrow occurs here\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 4 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 4 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0373, E0499, E0502.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0373, E0499, E0502.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0373`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0373`.\u001b[0m\n"}
